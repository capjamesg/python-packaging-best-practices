{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#best-practices-for-packaging-python-projects","title":"Best Practices for Packaging Python Projects","text":"<p>I have contributed to numerous Python packages over the last few months, from a package to use foundation vision  models to train smaller models to a small package for computing word surprisals. When I am working on packages, I  ask myself the question \"what can I do to make the developer experience as seamless as possible?\"</p> <p>Strong documentation and package organization is an excellent long-term investment. The more comprehensive and  intuitive your documentation is, the easier it is for people to use the library. Notably, good documentation makes  the lives of all maintainers (and future maintainers!) easier. Robust documentation makes it easier to navigate  and use a codebase, and helps to build a shared understanding around the structure of a codebase.</p> <p>There are a few tips I have picked up while working on packaging Python projects that I want to share. In this  article, I share the tasks, questions, and thoughts that come to mind when I am preparing to launch a Python  project. I cover everything from documentation to CI integrations to code style.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>When I am working on a Python package, I like to ensure I have:</p> <ol> <li>A well-written README;</li> <li>Comprehensive documentation for public-facing functions in the codebase, and;</li> <li>Auxillery information about the project (i.e. compatability, project organization, information if the package  is part of a broader ecosystem).</li> </ol> <p>What makes a well-written README? Good question!</p>"},{"location":"#readmes","title":"READMEs","text":"<p>My approach to READMEs is visual. What can I do to help make the project as approachable as possible? One  structure I like to follow in READMEs, inspired by the <code>supervision</code> project, is:</p> <ol> <li>Header image, if relevant</li> <li>A 1-2 sentence introduction of the project</li> <li>GitHub badges</li> <li>Brief installation instructions [^1]</li> <li>A quickstart, showing how to use key functions in the project</li> <li>Community resources</li> <li>Contributing information</li> <li>Citation</li> <li>License</li> </ol> <p>I will talk about each of these in their own sections.</p>"},{"location":"#header-image","title":"Header Image","text":"<p>A header image that is relevant to the project goes a long way to easing someone into a repository. If your  repository helps someone build something visual (i.e. an image processing library, a web compoenent), an image  showing the project in action is great.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>A short, snappy introduction to the project helps someone quickly evaluate if the repository is relevant to them.  Here are some examples from projects on which I have worked:</p> <ul> <li>Autodistill uses big, slower foundation models to train small, faster supervised models. Using <code>autodistill</code>,  you can go from unlabeled images to inference on a custom model running at the edge with no human intervention in  between.</li> <li>indieweb-utils provides building blocks for people  implementing IndieWeb applications in Python. Discover  IndieWeb  endpoints, find feeds on a page, infer page names, generate reply  contexts, and more!</li> <li><code>mf2py</code> is a full-featured microformats2 (mf2) parser implemented in Python. mf2py implements the full mf2  specification, including backward compatibility with microformats1.</li> </ul>"},{"location":"#github-badges","title":"GitHub Badges","text":"<p>GitHub badges visually convey useful information about your project. Some badges that may be relevant include:</p> <ol> <li>PyPi release badge, linking to your project</li> <li>Colab notebook (if relevant)</li> <li>Version number</li> <li>License</li> <li>Any other relevant information (Arxiv link, CI failing / passing)</li> </ol> <p>You should choose the badges that make sense to you. Sites useful for creating badges include:</p> <ol> <li>...</li> </ol>"},{"location":"#brief-installation-instructions","title":"Brief Installation Instructions","text":"<p>Installation instructions should be concise. Use as little text as you need to explain how to install your  project. If installation takes several steps, list each command. Separate commands with text explaining what each  one does.</p> <p>Be sure to note any device-specific installation instructions. Nest these under appropriate headings.</p> <p>Pro tip: Enclose any build from source instructions in a HTML <code>&lt;details&gt;</code> block so they don't take up too  much room, if you are publishing your README to a place that supports HTML parsing (i.e PyPi, GitHub).</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>One of my favourite parts of a README is the Quickstart. This is the code that shows how your project works, at a  high level.</p> <p>The Quickstart is an opportunity for you to showcase a selection of the most useful functions in your library.  Select up to three different code examples to share in the Quickstart, each nested under their own headings.</p>"},{"location":"#community-resources","title":"Community Resources","text":"<p>Have other people written articles or recorded videos about your project? Are there any examples from social media  you want to share? This is the place to document them! Resources from third-parties on how to use your project, or  resources you have complied yourself, all can be helpful someone who is new to your project.</p>"},{"location":"#contributing-information","title":"Contributing Information","text":"<p>Contribution guidelines are essential for projects that want to accept external contributions. If this is you,  allocate some time to write a <code>CONTRIBUTING.md</code> file, the file that outlines how people can contribute to your  project.</p> <p>Your contribution guidelines are a welcome message for people to contribute to your project. Use them to explain:</p> <ol> <li>The philosophy behind your project, and how this relates to the scope of what the project should do.</li> <li>How people can get started?</li> <li>Do you want them to file GitHub issues before a PR?</li> <li>How can people find out if something is already being worked on?</li> <li>Do contributors need to write test cases as part of their original commit, or after feedback has been given  by a reviewer?</li> <li>Do you have any resources to share that could be helpful (i.e. a tutorial for adding a new module to the  codebase)?</li> <li>The code of conduct to which your project adheres. The IndieWeb  community has a collection of many codes of conduct that can help  you write one for your project. If you opt to write your own code of conduct, save it in a file called  <code>CODE_OF_CONDUCT.md</code> in the main directory of your project.</li> </ol>"},{"location":"#citation","title":"Citation","text":"<p>Do you have a preferred way in which people can cite your project? Add it to your README! Optionally, create a  <code>CITATION.cff</code> file that shares how you would prefer people to cite your work. GitHub parses these files and  creates a human-readable interface with copy-paste examples for APA and BibTeX citations.</p>"},{"location":"#license","title":"License","text":"<p>There are many materials online that discuss choosing a license. Allocate time to choose a license that matches  your attribution desires, commercial requirements, and all of the other factors that are meaningful to you and  your contributors. GitHub has more information on how to choose a project license. Ask fellow developers who have  worked with open source licenses before if you have questions; do independent research to come to a conclusion.</p> <p>Your license should be saved in a file called <code>LICENSE</code>.</p>"},{"location":"#tldr-make-your-readme-pretty-comprehensive-and-actionable","title":"TL;DR: Make your README pretty, comprehensive, and actionable \u2728","text":""},{"location":"#project-documentation","title":"Project Documentation","text":"<p>READMEs are the first entry point for many developers to coding projects, but it should not be your only  documentation. Long READMEs with extensive technical text and examples can become unwieldy and cause information  overload. For documenting the full functionality of your project, and discussing specific topics in more depth,  you should maintain external documentation.</p> <p>Python documentation tools like mkdocs and sphinx create websites to host your project documentation. The  advantage of using a documentation tool built with Python in mind is that these tools often offer extensions that  work with your codebase. For example, you can use the <code>pydocstrings</code> module to use docstrings to generate  documentation with <code>mkdocs</code>. Sphinx has a module for generating documentation from docstrings, too.</p> <p>In your documentation, you should have:</p> <ol> <li>Your README (you worked so hard on it, why not re-use it for your project home page?)</li> <li>Links to important resources like your license, contributing guidelines, and code of conduct</li> <li>Coverage for your codebase (optional, but preferred)</li> </ol> <p>You should document all public functions and classes in your project. These functions should have:</p> <ol> <li>Type hints</li> <li>Clear, descriptive summaries</li> <li>Documentation for what each function parameter does</li> <li>Example usage, if relevant</li> </ol> <p>You can include all of this information in your Python docstrings. If you do, this information will be consumed by  more than just your documentation. For example, Visual Studio Code offers rich syntax highlighting based on some  information in docstrings. When you hover over a function name in Visual Studio Code, the IDE shows the docstring  information.</p>"},{"location":"#linting","title":"Linting","text":"<p>Everyone has their own code style preferences, but there is one thing on which we can all agree: it is easier to  both read and contribute to code that is consistent in style. Linters can help with this.</p> <p>You can use <code>black</code> to lint your code. Out of the box, black provides sane defaults for linting. Then, you can use  <code>isort</code> to order your import statements, ensuring consistency across your project.</p> <p>When you run a linter for the first time, be sure to do so in a separate PR if your project has other  contributors. Do not include any other code changes in such a PR. If your code has never been linted before, or  was not linted in a while, you will end up with lots of changes that are hard for someone to review. Your PR will  probably get rejected for this reason.</p> <p>To help people comply with your project linting requirements, create a <code>Makefile</code> that includes a command to run  the requisite commands to prepare code for review. Share guidance on how to use this command in your Contributing  guidelines.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>TODO</p>"},{"location":"#release-notes","title":"Release Notes","text":"<p>Release notes help developers track the evolution of your project. You should write release notes before  publishing any version of your project, if your project is a library intended for distribution. Keep note of all  of your release notes in a changelog. The Make a Changelog site has an easy-to-use template you can use to start  your project changelog.</p> <p>In your changelog, note:</p> <ul> <li>Additions: What methods and logic did you add to the project?</li> <li>Deprecations: Did you remove anything from the library?</li> <li>Bugs Fixed: What bugs did you fix? Include links to any GitHub Issues that may be relevant to the bug.</li> <li>And anything else you think is important for someone to know who is reading your changelog.</li> </ul>"},{"location":"#continuous-integration","title":"Continuous Integration","text":"<ul> <li>DRY in your project documentation</li> <li>Release checklist</li> <li>updated version in pyproject.toml / _ init _ .py</li> <li>written changelog</li> <li>created a version on github</li> <li>published release notes</li> <li>library promotion</li> <li>conclusion</li> <li>web demos?</li> </ul>"},{"location":"#conclusion","title":"Conclusion","text":"<p>This guide is intended as reference material for packaging Python projects and preparing them for release. In this  guide, we have covered everything from writing a comprehensive README to what to include in your project release  notes (if your project is a library).</p> <p>While packaging work can feel secondary to the \"main\" work of a project, writing strong documentation, developing  a continuous integration pipeline, and other pieces of advice mentioned in this e-book are a crucial part of  publishing a project.</p> <p>The easier your project is to understand and the less time it takes to solve a problem with your project, the  better. A big part of this is providing an easy way for someone to get started: concise installation instructions,  a web demo, etc.</p> <p>If you have any topics you would like to see covered in this e-book, or exapanded upon, please review our  contribution guidelines for more information. I am eager to include as much information as possible here, while  preserving conciseness, to build a one-stop-shop for key information about preparing Python projects for release.</p>"}]}